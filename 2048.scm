; Copyright (C) 2022 Daniil Shvachkin
; Released under the terms of the 3-clause BSD license 
(import ncurses srfi-1 srfi-25 (rename (chicken random) (pseudo-random-integer random)))

(define GAME_PLACE '(4 4))
(define CELL_SIZE '(5 6))
(define CELL_mrg '(2 1))
(define BASE_NUM 10)

(define (main)
	(initscr)
	(cbreak)
	(noecho)
	(clear)

	(let*((win (let ((gp (map * CELL_SIZE GAME_PLACE))) (apply newwin 
					(append gp (map 
						(lambda(s k) (truncate (/ (- s k) 2))) 
						(list (LINES) (COLS)) gp)))))
				(WS	(car GAME_PLACE))
				(HS (cadr GAME_PLACE))
				(nums (make-array (shape 0 WS 0 HS) 0))
				(sum (lambda(a b) (if (or (= a b) (zero? a) (zero? b)) (+ a b) #f)))
				(nget (lambda(k) (apply array-ref (cons nums k))))
				(nset! (lambda(k v) (apply array-set! (append (cons nums k) (list v)))))
				(nrand_add (lambda(c) 
					(let loop((i c)) (unless (zero? i) 
						(let next((np (map random GAME_PLACE)) (lim 50))
							(if (zero? lim) #f
								(if (sum (nget np) 2) 
									(nset! np (sum (nget np) 2)) 
									(next (map random GAME_PLACE) (- lim 1)))))))))
				(nprint (lambda()
					(do ((i 0 (+ i 1))) ((= i (car GAME_PLACE)))
						(do ((j 0 (+ j 1))) ((= j (cadr GAME_PLACE)))
							(let* ((dg (map + (map * CELL_SIZE (list i j)) CELL_mrg))
										(di (car dg)) (dj (cadr dg)))
								(mvwaddstr win di dj (number->string (nget (list i j)) BASE_NUM))))))))
		;(wtimeout win 800)
		(let loop((c #\p))
			(wclear win)
			(if (member c '(#\h #\l #\j #\k))
				(let*((forw (lambda(fin fn) (do ((k 0 (+ k 1))) ((= k fin)) (fn k))))
							(back (lambda (fin fn) (forw fin (lambda(q) (fn (- fin q 1))))))
							(srrest (lambda(l m) (append l (make-list (- m (length l)) 0))))
							(srsum (lambda(k v) (if (null? v) (cons k v) 
								(if (sum k (car v)) (cons (sum k (car v)) (cdr v)) (cons k v)))))
							(trans (lambda(m fn)
								(case c 
									((#\h) (fn m))
									((#\k) (fn (reverse m)))
									((#\l) (fn (list (car m) (- (cadr GAME_PLACE) 1 (cadr m))))) 
									((#\j) (fn (reverse (list (car m) (- (cadr GAME_PLACE) 1 (cadr m)))))))))
							(tget	(lambda(m) (trans m nget)))
							(tset! (lambda(m v) (trans m (lambda(q)(nset! q v))))))
					(forw (car GAME_PLACE) (lambda(i)
						(let ((line '()))
							(back (cadr GAME_PLACE) (lambda (j)
								(set! line (srsum (tget (list i j)) line))))
							(set! line (srrest line (car GAME_PLACE)))
							(forw (cadr GAME_PLACE) (lambda (j)
								(tset! (list i j) (car line))
								(set! line (cdr line)))))))))
			(nrand_add 2)
			(nprint)
			(wrefresh win)
		(unless (eq? c #\q) (loop(wgetch win)))))
	(endwin))

(main)
